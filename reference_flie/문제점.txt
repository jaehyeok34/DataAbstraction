문제 1. 송신 루틴 진행 중인 상태에서 수신 데이터가 전달 됐을 경우, 다음 진행되는 송신 루틴의 순서가 꼬임
 (1). 수신 데이터 list = ["1", "2"]
 (2). list 순회 for문에 의해 첫번째 인덱스인 "1"에 대한 송신 루틴 진행 중...
 (3). 송신 루틴이 진행중인 상황((2)번 상황)에서 수신 데이터 list에 "3", "4" 값 추가 = ["1", "2", "3", "4"]
 (4). "1"에 대한 송신 루틴 종료 후 수신 데이터 list의 가장 앞에 데이터 pop = ["2", "3", "4"]
 (4). list 순회 for문에 의해 두번째 인덱스인 "3"에 대한 송신 루틴 진행 중...
 (5). "3"에 대한 송신 루틴 종료 후 가장 앞에 데이터 pop = ["3", "4"]
이유:   송신 루틴이 끝나고 pop되는 데이터가 방금 처리한 데이터가 아닌, 수신 데이터 list의 가장 앞에 값이기 때문.

해결 1. 송신 루틴이 수신 데이터 list에 직접 접근하는 것이 아닌, 지금까지 쌓인 데이터를 새로운 list에 복사한 후,
        수신 데이터 list를 비우고, 송신 루틴은 새로 생성된 list(변경되지 않는)를 통해 루틴 진행

해결 1의 문제점
    1.  데이터의 복사로 인한 성능 저하
        -   단순 문자열일 경우에는 성능에 큰 영향이 없지만, 이미지 파일을 인코딩한 데이터 처럼
            크기가 커질 수록 성능 저하가 커질 것으로 예상됨

    2.  새로운 list에 값을 복사한 후, 수신 데이터 list를 비우기 직전에(해결된 문제)
        새로운 데이터가 수신 데이터 list에 추가 되면, 수신 데이터 list가 비워지면서 데이터 증발(저장과 동시에 삭제)
        -   극악의 타이밍이긴 하지만, 가능성이 있는 문제이기 때문에 치명적인 문제임.
        -   해결: 임계 구역을 설정하여 수신 데이터 list에 동시 접근을 막음으로서 저장과 동시에 삭제되는 현상 완전 해결

결론: 데이터의 복사로 인한 성능 저하를 감안하면 해결되는 문제
################################### 삽질 완료... ###################################
최종:   critical_section_control.py에서 임계 구역 설정을 통해 문제 1을 해결했지만, 복사로 인한 성능 저하를 해결하지 못함.
        하지만, 애초에 1회 송신 루틴(output 1회 호출)에서 수신 데이터 list의 가장 앞에 있는 데이터에 대한 처리만 진행하고
        그 이후는 다시 output이 호출 되면서 처리하게 하면 되는 거였음...

        기존에는 output 1회 호출에서 그동안 쌓인 모든 수신 데이터에 대한 처리를 하게끔 구현 했지만,
        그냥 output 1회에 데이터 송신 루틴 1회 하면 되는 거였...

        이를 구현한 control.py 참고
###################################################################################
문제 2. 수신 속도에 비해 송신 루틴 속도가 느리게 되면, 수신 데이터는 계속해서 쌓이게 됨.
    해결법 1. n개의 thread를 미리 생성해 두고, 수신 데이터가 들어 오면 쉬고 있던 thread가 이를 가져가서 처리
        -   임계 구역을 지정하여 n개의 thread가 지속적으로 self.recv_datas 확인하고, lock을 걸어 thread 고유 변수에
            pop 해가는 방식으로 구현.
        -   다른 thread가 송신 루틴을 진행하고 있으면, 쉬고 있던 thread 들만 self.recv_datas를 확인할 것임
        -   문제점: 몇 개의 thread를 생성할 것인가?
            -   thread 생성에도 비용이 들기 때문에, 오히려 더 많은 성능 저하를 야기할 수 있음
    해결법 2. n개 이상의 데이터가 쌓일 경우에만 새로운 thread를 생성해서 송신 루틴 진행
        -   n개 이상의 데이터가 쌓여서 새로운 thread를 생성했음에도 다시 쌓이면 또 새로운 thread 생성 반복
        -   문제점: n개의 기준이 모호함. thread의 종료 시점도 모호함.

